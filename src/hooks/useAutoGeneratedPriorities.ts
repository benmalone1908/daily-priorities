/**
 * Hook for generating auto-populated priority sections from campaign data
 */

import { useMemo } from 'react';
import { useQuery } from '@tanstack/react-query';
import { useSupabase } from '@/contexts/use-supabase';
import { AutoGeneratedPriority, CampaignRenewal } from '@/types/daily-priorities';
import { CampaignDataRow } from '@/types/campaign';
import { addDays, parseISO, format, isWithinInterval, differenceInDays } from 'date-fns';
import { processCampaigns } from '@/lib/pacingCalculations';
import type { ContractTerms, PacingDeliveryData } from '@/types/pacing';

interface AutoGeneratedSections {
  renewals: AutoGeneratedPriority[];
  pacing: AutoGeneratedPriority[];
  roas: AutoGeneratedPriority[];
}

export function useAutoGeneratedPriorities(
  targetDate: Date = new Date(),
  campaignData: CampaignDataRow[] = []
): AutoGeneratedSections {
  const { supabase } = useSupabase();
  const today = targetDate;

  // Fetch contract terms data for renewals
  const { data: contractTerms = [] } = useQuery<ContractTerms[]>({
    queryKey: ['contract-terms-all'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('contract_terms')
        .select('*');

      if (error) throw error;
      return data as ContractTerms[];
    },
    enabled: !!supabase
  });

  // Fetch renewal statuses
  const { data: renewalStatuses = [] } = useQuery<CampaignRenewal[]>({
    queryKey: ['campaign-renewals'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('campaign_renewals')
        .select('*');

      if (error) throw error;
      return data as CampaignRenewal[];
    },
    enabled: !!supabase
  });


  const autoSections = useMemo(() => {
    const sections: AutoGeneratedSections = {
      renewals: [],
      pacing: [],
      roas: []
    };

    // Create a map of renewal statuses by campaign name for easy lookup
    const renewalStatusMap = new Map(
      renewalStatuses.map(r => [r.campaign_order_name, r])
    );

    // Process contract terms for renewals
    if (contractTerms && contractTerms.length > 0) {
      contractTerms.forEach(contract => {
        // Try different field names that might exist in contract_terms
        const campaignName = contract.campaign_order_name || contract.campaign_name || contract.CAMPAIGN_ORDER_NAME;
        const endDate = contract.end_date || contract.END_DATE;

        // Skip if no end date or campaign name
        if (!endDate || !campaignName) {
          return;
        }

        // Skip test campaigns
        if (campaignName.toLowerCase().includes('test') ||
            campaignName.toLowerCase().includes('demo')) {
          return;
        }

        try {
          const parsedEndDate = parseISO(endDate);
          const daysUntilEnd = Math.ceil((parsedEndDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));

          // Show campaigns ending today or in next 15 days (exclude campaigns that already ended)
          if (daysUntilEnd >= 0 && daysUntilEnd <= 15) {
            // Get renewal status if it exists
            const renewalStatus = renewalStatusMap.get(campaignName);

            sections.renewals.push({
              client_name: campaignName,
              description: format(parsedEndDate, 'MMM d, yyyy'),
              metric: `${daysUntilEnd} days`,
              severity: daysUntilEnd <= 7 ? 'high' : daysUntilEnd <= 10 ? 'medium' : 'low',
              renewalStatus: renewalStatus?.renewal_status || 'Awaiting Confirmation',
              renewalId: renewalStatus?.id
            });
          }
        } catch (e) {
          console.error('Error parsing end date for renewals:', e);
        }
      });
    }

    // Process pacing data using contract terms and campaign data
    if (contractTerms.length > 0 && campaignData.length > 0) {
      // Convert contract terms to expected format
      // NOTE: Supabase returns lowercase snake_case fields from contract_terms table
      const pacingContractTerms: ContractTerms[] = contractTerms.map((row) => ({
        Name: (row as Record<string, unknown>).campaign_name as string || '',
        'Start Date': (row as Record<string, unknown>).start_date as string || '',
        'End Date': (row as Record<string, unknown>).end_date as string || '',
        Budget: ((row as Record<string, unknown>).budget || 0).toString(),
        CPM: ((row as Record<string, unknown>).cpm || 0).toString(),
        'Impressions Goal': ((row as Record<string, unknown>).impressions_goal || 0).toString()
      })).filter(ct => ct.Name); // Filter out any without names

      // Campaign data is already in the correct format (CampaignDataRow with uppercase fields)
      // Just convert to PacingDeliveryData format
      const deliveryData: PacingDeliveryData[] = campaignData.map((row: CampaignDataRow) => ({
        DATE: row.DATE || '',
        'CAMPAIGN ORDER NAME': row['CAMPAIGN ORDER NAME'] || '',
        IMPRESSIONS: (row.IMPRESSIONS || 0).toString(),
        SPEND: (row.SPEND || 0).toString()
      }));

      // Use the same processCampaigns function as the Pacing tab
      const processedCampaigns = processCampaigns(pacingContractTerms, deliveryData, deliveryData);

      processedCampaigns.forEach(campaign => {
        // Pacing data is in metrics.currentPacing (0-1 scale), convert to percentage
        const pacingPercent = (campaign.metrics?.currentPacing || 0) * 100;

        // Skip test campaigns
        if (campaign.name.toLowerCase().includes('test') ||
            campaign.name.toLowerCase().includes('demo')) {
          return;
        }

        // Show campaigns with pacing < 95% or > 105%
        if (pacingPercent < 95 || pacingPercent > 105) {
          // Calculate days left based on today's date vs. end date from contract terms
          const matchingContract = contractTerms.find((ct) => (ct as Record<string, unknown>).campaign_name === campaign.name);
          let daysLeft = 0;

          if (matchingContract?.end_date) {
            try {
              const endDate = parseISO(matchingContract.end_date);
              // Add 1 to include the end date as a "day left"
              daysLeft = Math.max(0, differenceInDays(endDate, today) + 1);
            } catch (e) {
              // If date parsing fails, use the metric from processCampaigns as fallback
              daysLeft = campaign.metrics?.daysUntilEnd || 0;
            }
          } else {
            // No contract found, use the metric from processCampaigns as fallback
            daysLeft = campaign.metrics?.daysUntilEnd || 0;
          }

          // Skip campaigns with zero or negative days left
          if (daysLeft <= 0) {
            return;
          }

          const isUnderPacing = pacingPercent < 95;
          sections.pacing.push({
            client_name: campaign.name,
            description: isUnderPacing
              ? `Under-pacing at ${pacingPercent.toFixed(1)}%`
              : `Over-pacing at ${pacingPercent.toFixed(1)}%`,
            metric: `${pacingPercent.toFixed(1)}%`,
            severity: pacingPercent < 85 || pacingPercent > 115 ? 'high'
                    : pacingPercent < 90 || pacingPercent > 110 ? 'medium'
                    : 'low',
            daysLeft: daysLeft,
            overallPacing: campaign.metrics?.currentPacing || 0,
            yesterdayRatio: campaign.metrics?.yesterdayVsNeeded || 0
          });
        }
      });
    }

    if (!campaignData || campaignData.length === 0) {
      return sections;
    }

    // Group data by campaign
    const campaignMap = new Map<string, CampaignDataRow[]>();
    campaignData.forEach(row => {
      const campaign = row['CAMPAIGN ORDER NAME'];
      if (!campaign) return; // Skip rows without campaign name
      if (!campaignMap.has(campaign)) {
        campaignMap.set(campaign, []);
      }
      campaignMap.get(campaign)!.push(row);
    });

    // Calculate metrics for each campaign
    campaignMap.forEach((rows, campaignName) => {
      const sortedRows = rows.sort((a, b) =>
        new Date(a.DATE).getTime() - new Date(b.DATE).getTime()
      );

      const totalImpressions = rows.reduce((sum, r) => sum + (r.IMPRESSIONS || 0), 0);
      const totalRevenue = rows.reduce((sum, r) => sum + (r.REVENUE || 0), 0);
      const totalSpend = rows.reduce((sum, r) => sum + (r.SPEND || 0), 0);

      // Skip test campaigns
      if (campaignName.toLowerCase().includes('test') ||
          campaignName.toLowerCase().includes('demo')) {
        return;
      }

      // Check ROAS (Return on Ad Spend)
      if (totalSpend > 0) {
        const roas = totalRevenue / totalSpend;

        // Flag campaigns with ROAS < 2.0 (adjustable threshold)
        if (roas < 2.0 && totalSpend > 100) { // Only flag campaigns with meaningful spend
          // Find matching contract term for days left
          const matchingContract = contractTerms.find((ct) => (ct as Record<string, unknown>).campaign_name === campaignName);
          let daysLeft = 0;

          if (matchingContract?.end_date) {
            try {
              const endDate = parseISO(matchingContract.end_date);
              // Add 1 to include the end date as a "day left"
              daysLeft = Math.max(0, differenceInDays(endDate, today) + 1);
            } catch (e) {
              // If date parsing fails, days left remains 0
            }
          }

          // Skip campaigns with zero or negative days left
          if (daysLeft <= 0) {
            return;
          }

          // Check if campaign has had impressions in the last 3 days
          const threeDaysAgo = new Date(today);
          threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);

          const recentRows = sortedRows.filter(row => {
            try {
              const rowDate = parseISO(row.DATE);
              return rowDate >= threeDaysAgo;
            } catch {
              return false;
            }
          });

          const recentImpressions = recentRows.reduce((sum, r) => sum + (r.IMPRESSIONS || 0), 0);

          // Skip campaigns with no impressions in the last 3 days
          if (recentImpressions === 0) {
            return;
          }

          sections.roas.push({
            client_name: campaignName,
            description: `Low ROAS: $${totalRevenue.toFixed(2)} revenue on $${totalSpend.toFixed(2)} spend`,
            metric: roas.toFixed(2),
            severity: roas < 1.0 ? 'high' : roas < 1.5 ? 'medium' : 'low',
            daysLeft: daysLeft
          });
        }
      }
    });

    // Sort renewals by days remaining (ascending - soonest first)
    sections.renewals.sort((a, b) => {
      const daysA = typeof a.metric === 'number' ? a.metric : parseInt(String(a.metric)) || 0;
      const daysB = typeof b.metric === 'number' ? b.metric : parseInt(String(b.metric)) || 0;
      return daysA - daysB;
    });

    // Sort pacing by metric (ascending - lowest pacing first)
    sections.pacing.sort((a, b) => {
      const pacingA = a.overallPacing || 0;
      const pacingB = b.overallPacing || 0;
      return pacingA - pacingB;
    });

    // Sort ROAS by severity
    const sortBySeverity = (a: AutoGeneratedPriority, b: AutoGeneratedPriority) => {
      const severityOrder = { high: 0, medium: 1, low: 2 };
      return severityOrder[a.severity || 'low'] - severityOrder[b.severity || 'low'];
    };

    sections.roas.sort(sortBySeverity);

    return sections;
  }, [campaignData, contractTerms, renewalStatuses, today]);

  return autoSections;
}
